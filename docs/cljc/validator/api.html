<!DOCTYPE html>
<html><html><head><style type="text/css">body{margin:0 0 0 560px;padding:60px 48px}div{box-sizing:border-box}pre{display:block;margin:0;letter-spacing:.8px}.scroll-x{overflow-x:auto}.scroll-y{flex-grow:1;overflow-y:auto}a,a:active,a:hover,a:visited{display:block;text-decoration:none}a.inline-link{display:inline-block}a.inline-link:hover{text-decoration:underline}.button{font-size:13px;letter-spacing:.5px;line-height:18px;padding:3px 12px;white-space:inherit}.button:hover{background-color:#f0f0f0}.button--active{background-color:#f3f3f3}.button--active:hover{background-color:#f0f0f0}.text--xs{font-size:10px;line-height:24px;text-transform:uppercase}.text--s{font-size:12px;line-height:18px}.text--m{font-size:13px;line-height:18px}.text--l{font-size:14px;line-height:18px}.text--semi-bold{font-weight:500}.text--bold{font-weight:600}.text--wrap{white-space:normal}.color--basic{color:#303030}.color--primary{color:#0088cc}.color--secondary{color:#8800cc}.color--muted{color:#606060}.color--warning{color:#cc00aa}.collapsible-wrapper{display:flex;flex-direction:column}.collapsible-button{cursor:pointer;position:relative;user-select:none;width:fit-content}.collapsible-button:hover{color:#888}.collapsible-button::after{align-items:center;content:'▼';display:flex;font-size:8px;justify-content:center;position:absolute;height:24px;right:-24px;top:0;width:24px}.collapsible-wrapper[data-expanded="true"] .collapsible-button::after{content:'▲'}.collapsible-wrapper .collapsible-content{display:none}.collapsible-wrapper[data-expanded="true"] .collapsible-content{display:block}#top-bar{background-color:#ffffff;border-bottom:1px solid #e0e0e0;display:flex;gap:6px;height:60px;left:0;padding-left:18px;position:fixed;top:0;width:100%}#top-bar--library-uri{font-size:12px;line-height:60px;padding:0 18px;position:absolute;right:0;top:0}#top-bar--library-uri:hover{background-color:#f0f0f0}#top-bar--library-name{font-size:18px;line-height:60px;text-transform:uppercase}#top-bar--author-name{font-size:12px}#top-bar--library-version{font-size:12px;line-height:18px;margin-top:12px}#bottom-bar{background-color:white;border-top:1px solid #e0e0e0;bottom:0;display:flex;justify-content:right;left:0;position:fixed;width:100%}#bottom-bar--credits-link{color:#aa55bb;font-size:12px;letter-spacing:.8px;line-height:42px;padding:0 18px}#bottom-bar--credits-link:hover{background-color:#f0f0f0}#primary-list{background-color:#fff;border-right:1px solid #e0e0e0;display:flex;flex-direction:column;height:calc(100vh - 60px);left:0;padding:12px 0 54px 0;position:fixed;top:60px;width:280px}#secondary-list{background-color:#fff;border-right:1px solid #e0e0e0;display:flex;flex-direction:column;height:calc(100vh - 60px);left:280px;padding:12px 0 54px 0;position:fixed;top:60px;width:280px}#primary-list,#secondary-list{z-index:9999}#primary-list .text--xs,#secondary-list .text--xs{padding-left:12px}.primary-list--container,.secondary-list--container{margin-bottom:12px}#namespace-header--title{font-size:18px;line-height:24px;margin-top:24px}#declarations{display:flex;flex-direction:column}.declaration--wrapper{padding-top:96px}.declaration--name{border-bottom:1px solid #e0e0e0;font-size:18px;line-height:18px;padding-bottom:8px;margin-bottom:12px}.tutorial--wrapper{padding-top:96px}.tutorial--name{border-bottom:1px solid #e0e0e0;font-size:18px;line-height:18px;padding-bottom:8px;margin-bottom:12px}.content-blocks{display:flex;flex-direction:column}.content-block--separator{height:12px}.content-block--label{display:flex;gap:4px;line-height:24px}.content-block--preview-image{border:1px solid #dedede;display:block;max-height:480px;max-width:640px;min-height:48px;min-width:64px}.content-block--boxed{background-color:#fafafa;color:#333;padding:12px 8px}</style><script type="text/javascript">function toggleCollapsible(collapsibleId){collapsible=document.getElementById(collapsibleId);if(collapsible.dataset.expanded==='true'){collapsible.dataset.expanded='false';}else{collapsible.dataset.expanded='true';}}</script></head><body><div id="primary-list"><div class="scroll-y"><div class="primary-list--container"><pre class="color--muted text--xs">Isomorphic namespaces</pre><a href="https://bithandshake.github.io/cljc-validator/cljc/validator/api.html"><pre class="button color--primary button--active">validator.api</pre></a></div></div></div><div id="secondary-list"><div class="scroll-y"><div class="secondary-list--container"><pre class="text--xs color--muted">Declarations</pre><a href="#disable-validator_"><pre class="button color--primary">disable-validator!</pre></a><a href="#enable-validator_"><pre class="button color--primary">enable-validator!</pre></a><a href="#invalid_"><pre class="button color--primary">invalid?</pre></a><a href="#reg-test_"><pre class="button color--primary">reg-test!</pre></a><a href="#valid_"><pre class="button color--primary">valid?</pre></a></div></div></div><div id="namespace-header"><pre class="text--bold" id="namespace-header--title">validator.api</pre><pre class="color--muted text--xs">Isomorphic namespace</pre></div><div id="tutorials--wrapper"><div id="tutorials"></div></div><div id="declarations--wrapper"><div id="declarations"><div class="declaration--wrapper" id="valid_"><pre class="color--muted text--xs">Declaration</pre><pre class="color--primary declaration--name text--bold">valid?</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="color--muted text--xs">Description</pre></div><pre class="color--basic text--m text--wrap">Returns TRUE if the given data passes the given test.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="color--muted text--xs">Param</pre><pre class="color--default text-s">data</pre><pre class="color--muted text--xs">*</pre><pre class="color--muted text--xs">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="color--muted text--xs">Param</pre><pre class="color--default text-s">test</pre><pre class="color--muted text--xs">keyword or map</pre><pre class="color--muted text--xs">required</pre></div><pre class="color--muted text--s scroll-x">Defines a set of functions for testing the given data.<br>If keyword, it identifies a registered reusable test.<br>{:allowed* (vector)(opt)<br>  Defines the allowed keys of the data (for map type data).<br> :and* (functions in vector)(opt)<br>  All functions in this vector must return TRUE.<br> :e* (string)<br>  The error message (printed if any test fails).<br> :f* (function)(opt)<br>  This function must return TRUE.<br> :ign* (boolean)(opt)<br>  If TRUE, all tests will be ignored.<br> :nand* (functions in vector)(opt)<br>  At least one function in this vector must return FALSE.<br> :nor* (functions in vector)(opt)<br>  All functions in this vector must return FALSE.<br> :not* (function)(opt)<br>  This function must return FALSE.<br> :opt* (boolean)(opt)<br>  If TRUE, the value is allowed to be NIL.<br> :or* (functions in vector)(opt)<br>  At least one function in this vector must return TRUE.<br> :required* (vector)(opt)<br>  Defines the required keys of the data (for map type data).<br> :xor* (functions in vector)(opt)<br>  At most one function in this vector can return TRUE.<br> :my-key (map)(opt)<br>  Test functions under custom keys are applied on the corresponding value (for map type data).<br>  Custom keys must be present in the given data also.<br>  {:rep* (vector)(opt)<br>    Vector of keys that could replace a specific key (if missing or NIL) in the data.}}</pre></div><div class="content-block"><div class="content-block--label"><pre class="color--muted text--xs">Param</pre><pre class="color--default text-s">options</pre><pre class="color--muted text--xs">map</pre><pre class="color--muted text--xs">optional</pre></div><pre class="color--muted text--s scroll-x">{:explain? (boolean)(opt)<br>  If TRUE, the error message will be printed.<br>  Default: true<br> :prefix (string)(opt)<br>  Prepended to the error message.}</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="color--muted text--xs">Usage</pre></div><pre class="text--s scroll-x content-block--boxed">(valid? "abc"<br>        {:f* string? :e* "Value must be a string!"})<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="color--muted text--xs">Usage</pre></div><pre class="text--s scroll-x content-block--boxed">(valid? {:a "A"}<br>        {:f* map? :e* "Value must be a map!"}<br>         :a {:f* string? :not* empty? :e* "Key :a must be a nonempty string!"})<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="color--muted text--xs">Usage</pre></div><pre class="text--s scroll-x content-block--boxed">(valid? {:a "A"}<br>        {:a {:or* [keyword? string?] :e* "Key :a must be a keyword or a string!"}})<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="color--muted text--xs">Usage</pre></div><pre class="text--s scroll-x content-block--boxed">(valid? {:a ""}<br>        {:a {:and* [string? empty?] :e* "Key :a must be an empty string!"}})<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="color--muted text--xs">Usage</pre></div><pre class="text--s scroll-x content-block--boxed">(valid? {:b "B"}<br>        {:a {:rep* [:b] :e* "Value must contain at least one of key :a or key :b!"}})<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="color--muted text--xs">Usage</pre></div><pre class="text--s scroll-x content-block--boxed">(valid? {}<br>        {:a {:rep* [:b] :e* "Value must contain at least one of key :a or key :b!"}})<br>=&gt;<br>false</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="color--muted text--xs">Usage</pre></div><pre class="text--s scroll-x content-block--boxed">(valid? {:a "a"}<br>        {:required* [:a :b] :e* "Value must contain key :a and key :b!"}<br>=&gt;<br>false</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="color--muted text--xs">Usage</pre></div><pre class="text--s scroll-x content-block--boxed">(valid? {:a "a"}<br>        {:allowed* [:a :b] :e* "Value cannot contain keys other than key :a or key :b!"}<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="color--muted text--xs">Usage</pre></div><pre class="text--s scroll-x content-block--boxed">(reg-test! :my-test {:a {:f* string?}})<br>(valid? {:a "A"} :my-test)<br>=&gt;<br>true</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="color--muted text--xs">Return</pre><pre class="color--muted text--xs">boolean</pre><pre class="color--muted text--xs"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="valid_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;valid_-source-code&apos;)">Source Code</pre><pre class="collapsible-content content-block--boxed text-s scroll-x">(defn valid?<br>  ([data test]<br>   (valid? data test {}))<br><br>  ([data test {:keys [explain? prefix] :or {explain? true}}]<br>   (letfn [<br>           (tst [test] (cond (map? test) test (keyword? test) (get @state/TESTS test)))<br><br>           (asm> [x test t] (str "\n\nvalidation failed at test:\n"  (if (nil? test) "NIL" test)<br>                                 "\n\nvalidation failed at stage:\n" (if (nil? t)    "NIL" t)<br>                                 "\n\nvalidation failed on value:\n" (if (nil? x)    "NIL" x)<br>                                 "\n\nvalidation failed on data:\n"  (if (nil? data) "NIL" data)<br>                                 "\n\n" prefix (if prefix " ") (:e* test) "\n"))<br><br>           (err> [x test t] #?(:clj  (throw (Exception. (do (println (asm> x test t)) (str test))))<br>                               :cljs (throw (js/Error.  (do (println (asm> x test t)) (str test))))))<br><br>           (dis? [] (-> state/ENABLED? deref not))<br><br>           (ign? [_ test]<br>                 (:ign* test))<br><br>           (opt? [x test]<br>                 (and (:opt* test) (nil? x)))<br><br>           (rep? [x test]<br>                 (and (:rep* test) (nil? x) (rep* data (:rep* test))))<br><br>           (chk? [x test]<br>                 (or ((:type* test) x) (err> x test :type*)))<br><br>           (rep* [x rep*]<br>                 (chk? rep* {:type* vector?  :e* :rep*-must-be-vector})<br>                 (chk? x    {:type* seqable? :e* :unable-check-replacement-key/non-seqable-data})<br>                 (some #(get x %) rep*))<br><br>           (awd* [x awd*]<br>                 (chk? awd* {:type* vector?  :e* :allowed*-must-be-vector})<br>                 (chk? x    {:type* seqable? :e* :unable-check-allowed-key/non-seqable-data})<br>                 (-> awd* set (remove (keys x)) empty?))<br><br>           (rqd* [x rqd*]<br>                 (chk? rqd* {:type* vector?  :e* :required*-must-be-vector})<br>                 (chk? x    {:type* seqable? :e* :unable-check-required-keys/non-seqable-data})<br>                 (-> x keys set (remove rqd*) empty?))<br><br>           (and* [x and*]<br>                 (chk? and* {:type* vector? :e* :and*-must-be-vector})<br>                 (or (every? #(f* x %) and*)))<br><br>           (f* [x f*]<br>               (chk? f* {:type* ifn? :e* :f*-must-be-function})<br>               (f* x))<br><br>           (nand* [x nand*]<br>                  (chk? nand* {:type* vector? :e* :nand*-must-be-vector})<br>                  (some #(not* x %) nand*))<br><br>           (nor* [x nor*]<br>                 (chk? nor* {:type* vector? :e* :nor*-must-be-vector})<br>                 (every? #(not* x %) nor*))<br><br>           (not* [x not*]<br>                 (chk? not* {:type* ifn? :e* :not*-must-be-function})<br>                 (-> x not* not))<br><br>           (or* [x or*]<br>                (chk? or* {:type* vector? :e* :or*-must-be-vector})<br>                (some #(f* x %) or*))<br><br>           (xor* [x xor*]<br>                 (chk? xor* {:type* vector? :e* :xor*-must-be-vector})<br>                 (loop [? false [% :as xor*] xor*]<br>                       (cond (-> xor* count zero?) true<br>                             (f* x %) (if ? false (recur true (drop xor*))))))<br><br>           (tst* [x k t]<br>                 (case k :e*        :non-test-key<br>                         :opt*      :non-test-key<br>                         :rep*      :non-test-key<br>                         :and*      (and*  x t)<br>                         :f*        (f*    x t)<br>                         :nand*     (nand* x t)<br>                         :nor*      (nor*  x t)<br>                         :not*      (not*  x t)<br>                         :or*       (or*   x t)<br>                         :xor*      (xor*  x t)<br>                         :allowed*  (awd*  x t)<br>                         :required* (rqd*  x t)<br>                                    (vld? (get x k) (tst t)))) <br><br>           (vld> [x {:keys [e*] :as test}]<br>                 (if (nil? x) (err> x test :nil?))<br>                 (every? (fn [[k t]] (or (tst* x k t) (err> x test k))) test))<br><br>           (vld? [x test]<br>                 (chk? test {:type* map? :e* :test-must-be-map})<br>                 (cond (dis?)        :validation-turned-off<br>                       (ign? x test) :skip-validation<br>                       (opt? x test) :nil-value-but-optional<br>                       (rep? x test) :nil-value-but-replaced<br>                       :validation (vld> x test)))]<br><br>          #?(:clj  (boolean (try (vld? data (tst test)) (catch Exception e (if explain? (-> e         println)))))<br>             :cljs (boolean (try (vld? data (tst test)) (catch :default  e (if explain? (-> e .-stack println)))))))))</pre></div></div><div class="declaration--wrapper" id="invalid_"><pre class="color--muted text--xs">Declaration</pre><pre class="color--primary declaration--name text--bold">invalid?</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="color--muted text--xs">Description</pre></div><pre class="color--basic text--m text--wrap">Returns TRUE if the given data fails the given test.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="color--muted text--xs">Param</pre><pre class="color--default text-s">data</pre><pre class="color--muted text--xs">*</pre><pre class="color--muted text--xs">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="color--muted text--xs">Param</pre><pre class="color--default text-s">test</pre><pre class="color--muted text--xs">keyword or map</pre><pre class="color--muted text--xs">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="color--muted text--xs">Param</pre><pre class="color--default text-s">options</pre><pre class="color--muted text--xs">map</pre><pre class="color--muted text--xs">optional</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="color--muted text--xs">Return</pre><pre class="color--muted text--xs">boolean</pre><pre class="color--muted text--xs"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="invalid_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;invalid_-source-code&apos;)">Source Code</pre><pre class="collapsible-content content-block--boxed text-s scroll-x">(defn invalid?<br>  ([data test]<br>   (invalid? data test {}))<br><br>  ([data test options]<br>   (-> data (valid? test options) not)))</pre></div></div><div class="declaration--wrapper" id="reg-test_"><pre class="color--muted text--xs">Declaration</pre><pre class="color--primary declaration--name text--bold">reg-test!</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="color--muted text--xs">Description</pre></div><pre class="color--basic text--m text--wrap">Registers a reusable test identified by the given ID.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="color--muted text--xs">Param</pre><pre class="color--default text-s">test-id</pre><pre class="color--muted text--xs">keyword</pre><pre class="color--muted text--xs">required</pre></div></div><div class="content-block"><div class="content-block--label"><pre class="color--muted text--xs">Param</pre><pre class="color--default text-s">test</pre><pre class="color--muted text--xs">map</pre><pre class="color--muted text--xs">required</pre></div></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="color--muted text--xs">Usage</pre></div><pre class="text--s scroll-x content-block--boxed">(reg-test! :my-test {:f* string? :e* "Value must be a string!"})</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="color--muted text--xs">Return</pre><pre class="color--muted text--xs">map</pre><pre class="color--muted text--xs"></pre></div></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="reg-test_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;reg-test_-source-code&apos;)">Source Code</pre><pre class="collapsible-content content-block--boxed text-s scroll-x">(defn reg-test!<br>  [test-id test]<br>  (-> state/TESTS (swap! assoc test-id test))<br>  (-> test))</pre></div></div><div class="declaration--wrapper" id="disable-validator_"><pre class="color--muted text--xs">Declaration</pre><pre class="color--primary declaration--name text--bold">disable-validator!</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="color--muted text--xs">Description</pre></div><pre class="color--basic text--m text--wrap">Turns off the validator.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="color--muted text--xs">Usage</pre></div><pre class="text--s scroll-x content-block--boxed">(disable-validator!)</pre></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="disable-validator_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;disable-validator_-source-code&apos;)">Source Code</pre><pre class="collapsible-content content-block--boxed text-s scroll-x">(defn disable-validator!<br>  []<br>  (reset! state/ENABLED? false))</pre></div></div><div class="declaration--wrapper" id="enable-validator_"><pre class="color--muted text--xs">Declaration</pre><pre class="color--primary declaration--name text--bold">enable-validator!</pre><div class="content-blocks"><div class="content-block"><div class="content-block--label"><pre class="color--muted text--xs">Description</pre></div><pre class="color--basic text--m text--wrap">Turns on the validator.</pre></div><div class="content-block--separator"></div><div class="content-block"><div class="content-block--label"><pre class="color--muted text--xs">Usage</pre></div><pre class="text--s scroll-x content-block--boxed">(enable-validator!)</pre></div></div><div class="content-block--separator"></div><div class="collapsible-wrapper" data-expanded="false" id="enable-validator_-source-code"><pre class="collapsible-button text--xs text--semi-bold" onClick="toggleCollapsible(&apos;enable-validator_-source-code&apos;)">Source Code</pre><pre class="collapsible-content content-block--boxed text-s scroll-x">(defn enable-validator!<br>  []<br>  (reset! state/ENABLED? true))</pre></div></div></div></div><div id="top-bar"><pre class="text--bold" id="top-bar--library-name">cljc-validator</pre><pre class="color--muted" id="top-bar--library-version">0.0.6.1</pre><a href="https://github.com/bithandshake/cljc-validator" id="top-bar--library-uri"><pre class="color--primary">github.com/bithandshake/cljc-validator</pre></a></div><div id="bottom-bar"><a href="https://github.com/mt-devtools/clj-source-code-documentation" id="bottom-bar--credits-link"><pre>github.com/mt-devtools/clj-source-code-documentation</pre></a></div></body></html></html>
